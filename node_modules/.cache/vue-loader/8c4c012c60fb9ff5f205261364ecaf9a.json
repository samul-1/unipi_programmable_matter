{"remainingRequest":"/home/samuele/Desktop/vue/programmable_matter/node_modules/vue-loader-v16/dist/index.js??ref--1-1!/home/samuele/Desktop/vue/programmable_matter/src/components/Particle.vue?vue&type=template&id=93644894&ts=true","dependencies":[{"path":"/home/samuele/Desktop/vue/programmable_matter/src/components/Particle.vue","mtime":1644253294379},{"path":"/home/samuele/Desktop/vue/programmable_matter/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/samuele/Desktop/vue/programmable_matter/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/samuele/Desktop/vue/programmable_matter/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/home/samuele/Desktop/vue/programmable_matter/node_modules/vue-loader-v16/dist/templateLoader.js","mtime":499162500000},{"path":"/home/samuele/Desktop/vue/programmable_matter/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/samuele/Desktop/vue/programmable_matter/node_modules/vue-loader-v16/dist/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiAgPHYtY2lyY2xlIHYtaWY9InN0YXRlID09ICdjb250cmFjdGVkJyIgOmNvbmZpZz0iY29uZmlnIj48L3YtY2lyY2xlPgogIDx2LWVsbGlwc2Ugdi1lbHNlIDpjb25maWc9ImVsbGlwc2VDb25maWdzW2FuZ2xlXSI+PC92LWVsbGlwc2U+Cg=="},{"version":3,"sources":["/home/samuele/Desktop/vue/programmable_matter/src/components/Particle.vue"],"names":[],"mappings":";EACE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAClE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC","file":"/home/samuele/Desktop/vue/programmable_matter/src/components/Particle.vue","sourceRoot":"","sourcesContent":["<template>\n  <v-circle v-if=\"state == 'contracted'\" :config=\"config\"></v-circle>\n  <v-ellipse v-else :config=\"ellipseConfigs[angle]\"></v-ellipse>\n</template>\n\n<script lang=\"ts\">\nimport {\n  ExtensionAngle,\n  GridPoint,\n  IParticle,\n  ParticleState\n} from '@/interfaces'\nimport {\n  configCircle,\n  diagonalEllipseConfig,\n  horizontalEllipseConfig,\n  OFFSET_180_DEG_ELLIPSE_X,\n  OFFSET_180_DEG_ELLIPSE_Y,\n  OFFSET_240_DEG_ELLIPSE_X,\n  OFFSET_240_DEG_ELLIPSE_Y,\n  OFFSET_60_DEG_ELLIPSE_X,\n  OFFSET_60_DEG_ELLIPSE_Y\n} from '@/shapes'\nimport { defineComponent, PropType } from '@vue/runtime-core'\nimport { mapState } from 'vuex'\n\nexport default defineComponent({\n  name: 'Particle',\n  props: {\n    particle: {\n      type: Object as PropType<IParticle>,\n      required: true\n    }\n  },\n  created () {\n    setInterval(() => this.moveToRandomNeighbor(), 10)\n  },\n  data () {\n    return {}\n  },\n  methods: {\n    moveToRandomNeighbor () {\n      if (!this.move) {\n        return\n      }\n      // console.log(\n      //   'I AM AT (',\n      //   this.particle.currentRow,\n      //   ', ',\n      //   this.particle.currentCol,\n      //   ') NEIGHBORS',\n      //   this.neighborPoints.map(\n      //     (p: GridPoint) => `(${p.gridRow}, ${p.gridCol})`\n      //   )\n      // )\n      if (this.target && this.$store.getters.isGridPointFree(this.target)) {\n        this.$store.commit('moveParticleToTarget', {\n          id: this.particle.id\n        })\n      } else {\n        const target = this.getNextTarget()\n        if (target) {\n          this.$store.commit('updateParticleTarget', {\n            id: this.particle.id,\n            target\n          })\n        }\n      }\n    },\n    getNextTarget (): GridPoint | null {\n      const freeNeighborInterval = this.$store.getters.getFreeNeighborsInterval(\n        this.point\n      ) as GridPoint[]\n\n      //console.log('FREE NEIGHBORS', freeNeighborInterval, 'I AM', this.point)\n\n      if (freeNeighborInterval.length > 2 && freeNeighborInterval.length < 6) {\n        const targetIndex = Math.floor(freeNeighborInterval.length / 2)\n        return freeNeighborInterval[targetIndex]\n      }\n\n      return null\n    }\n  },\n\n  computed: {\n    ellipseConfigs () {\n      return {\n        '60': {\n          x: this.x - OFFSET_60_DEG_ELLIPSE_X, //10,\n          y: this.y - OFFSET_60_DEG_ELLIPSE_Y, //15,\n          ...diagonalEllipseConfig,\n          fill: this.particle.color,\n          rotation: 60\n        },\n        '180': {\n          x: this.x + OFFSET_180_DEG_ELLIPSE_X, // 17.5,\n          y: this.y + OFFSET_180_DEG_ELLIPSE_Y,\n          ...horizontalEllipseConfig,\n          fill: this.particle.color,\n          rotation: 180\n        },\n        '-180': {\n          x: this.x - OFFSET_180_DEG_ELLIPSE_X,\n          y: this.y + OFFSET_180_DEG_ELLIPSE_Y,\n          ...horizontalEllipseConfig,\n          fill: this.particle.color,\n          rotation: -180\n        },\n        '-60': {\n          x: this.x + OFFSET_60_DEG_ELLIPSE_X, // + 10,\n          y: this.y - OFFSET_60_DEG_ELLIPSE_Y, // - 15,\n          ...diagonalEllipseConfig,\n          fill: this.particle.color,\n          rotation: -60\n        },\n        '240': {\n          x: this.x + OFFSET_240_DEG_ELLIPSE_X, //+ 8.5,\n          y: this.y + OFFSET_240_DEG_ELLIPSE_Y, // 15,\n          ...diagonalEllipseConfig,\n          fill: this.particle.color,\n          rotation: 240\n        },\n        '-240': {\n          x: this.x - OFFSET_240_DEG_ELLIPSE_X, // 8.5,\n          y: this.y + OFFSET_240_DEG_ELLIPSE_Y, // 15,\n          ...diagonalEllipseConfig,\n          fill: this.particle.color,\n          rotation: -240\n        }\n      }\n    },\n    point () {\n      return this.$store.getters.getPoint(\n        this.particle.currentRow,\n        this.particle.currentCol\n      )\n    },\n    position (): { x: number; y: number } {\n      if (this.point) {\n        return { x: this.point.x, y: this.point.y }\n      }\n\n      return { x: 0, y: 0 }\n    },\n    x () {\n      return this.position.x\n    },\n    y () {\n      return this.position.y\n    },\n    neighborPoints (): GridPoint[] {\n      return this.$store.getters.getNeighbors(this.point)\n    },\n    state (): ParticleState {\n      return this.$store.getters.getParticleState(this.particle.id)\n    },\n    angle (): ExtensionAngle {\n      return this.$store.getters.getParticleExtensionAngle(this.particle.id)\n    },\n    target (): GridPoint | undefined {\n      return this.$store.getters.getParticleTarget(this.particle.id)\n    },\n    config () {\n      return {\n        x: this.x,\n        y: this.y,\n        fill: this.particle.color,\n        ...configCircle\n      }\n    },\n    ...mapState(['move'])\n  }\n})\n</script>\n\n<style></style>\n"]}]}